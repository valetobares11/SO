/*
> p > file 
1. fork()
2. En el hijo
	2.1 redirigir
	2.2 exec
3. En el padre
	3.1 esperar por el hijo 
	

	int status =0;
	if (fork() == 0){
		exec("p");
	}
	wait (&status);
	


int fd = open(file, O_WRONLY, O_CREATE);
close(1);
dup(fd);
exec("p");

*/


/*
	> p ;q
	
	int status =0;
	if (fork() ==0){
		exec("p");
	}
	wait (&status);
	
	if (fork() ==0){
		exec("q");
	}
	wait(& status);

*/
/*
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
int systen(char* cmd)
{
    int childpip = fork();
    if(childpip == 0){
        char* words[3];
        char* spe = cmd;
        words[0] = cmd;
        words[2] = 0;
        while(spe != ' ')
            spe++;
        words[1] = spe + 1;
        *spe = '\0';
        execv(words[0], words);
    } else {
        int status;
        wait(&status);
        return status;
    }
}*/


/*
	p && q

	if (fork() == 0){
		exec("p");
	}
	wait(&status);
	if (status==0){
		if (fork()==0){
			exec("q")
		}
		wait(&status)
	}


	p || q

	if (fork() == 0){
		exec("p");
	}
	wait(&status);
	if (status!=0){
		if (fork()==0){
			exec("q")
		}
		wait(&status)
	}


	P & q

	if (fork()==0)
		exec("p");
	if (fork()==0)
		exec("q");
	wait(&status);
	wait(&status);
	return status;


	p | q

	int  t[2];
	pipe(t);
	if (fork()==0){
		close(1);
		dup(t[1])
		close(t[0])
		exec("p")
	}
	if (fork()==0){
		close(0)
		dup(t[0])
		close(t[1])
		exec("p")
	}
	wait(&status);
	wait(&status);
	return status;
*/